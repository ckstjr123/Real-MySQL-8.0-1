# 5. 트랜잭션과 잠금

## 5.1 트랜잭션

### 5.1.2 주의사항
- 트랜잭션은 꼭 필요한 코드에만 적용하여 범위를 최소화 하는 것이 좋음  
  각 단위 프로그램이 커넥션을 소유하는 시간이 길어지면 여유 커넥션이 부족해서  
  커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있음
- 메일 전송, 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게 해서든 트랜잭션에서 배제해야 함
  ex) 프로그램 실행 중 메일 서버와 통신할 수 없는 상황이 발생하면 웹 서버뿐아니라 DBMS 서버까지 위험 

---

## 5.3 InnoDB 스토리지 엔진 잠금

### 5.3.1.1 레코드 락
> 레코드 자체만을 대상으로 잠금
- InnoDB 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금
- 내부적으로 클러스터 인덱스를 이용해 잠금 설정
- InnoDB는 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락(Next key lock)/갭 락(Gap lock)을 사용하지만,  
  프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 레코드에 대해서만 잠금

### 5.3.1.2 갭 락
> 레코드가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠금
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어
- 갭 락 그 자체보다는 넥스트 키 락의 일부로 자주 사용됨

### 5.3.1.3 넥스트 키 락
> 레코드 락과 갭 락을 합친 형태의 잠금

--- 

## 5.4 MySQL의 격리 수준

### 5.4.1 READ UNCOMMITTED
> 각 트랜잭션의 변경 내용이 COMMIT/ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보임
- 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 더티 리드(Dirty read) 초래

### 5.4.2 READ COMMITTED
> 어떤 트랜잭션에서 데이터를 변경했더라도 다른 트랜잭션에선 COMMIT이 완료된 데이터만 조회
- 사용자가 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는  
  항상 같은 결과를 가져와야 한다는 "REPEATABLE READ" 정합성에 어긋남

### 5.4.3 REPEATABLE READ
> 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장
- 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 PHANTOM READ
  - InnoDB 엔진에서도 Locking Reads("SELECT ... FOR UPDATE" 또는 "SELECT ... FOR SHARE")를 사용하는 경우엔
    REPEATABLE READ 격리 수준에서 PHANTOM READ 현상이 나타날 수 있지만,
    레코드 변경 이력(언두 레코드)에 잠금을 걸 수는 없기 때문에
    이러한 잠금을 동반한 SELECT 쿼리는 예외적인 상황으로 취급할 수 있음

### 5.4.4 SERIALIZABLE
> 가장 단순한 격리 수준인 동시에 가장 엄격한 격리 수준
- 다른 트랜잭션 격리 수준에 비해 동시 처리 성능이 떨어짐
- 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 함
